---
title: Hakyll
tags: haskell, hakyll
---

You may have noticed that this blog is proudly powered by Hakyll. [Many others](https://jaspervdj.be/hakyll/examples.html) have posted about setting up or transitioning to Hakyll, but I thought I'd recount my experience anyway. I'm a novice with Haskell, so forgive me if some of the following isn't quite the Haskell way.

I won't cover setting up RSS because there are several other posts and an official tutorial on the Hakyll site that cover this.

## NPM, Bootstrap and lesscss
I wanted to use NPM to manage Bootstrap and other frontend dependencies. T I'm not sure that the way I solved this is necessarily the best, so maybe someone could point me in the right direction. Basically we want to ensure that npm install

Much of the following is poached directly from [https://meta.plasm.us](https://meta.plasm.us)--Thanks Travis.

```haskell
match (fromList $ lessFiles defaultEngineConfig) $ do
    route $ setExtension "css"
    compile $ getResourceString
        >>= withItemBody (unixFilter (lessCommand defaultEngineConfig) $ "-" : (lessOptions defaultEngineConfig))
        >>= return . fmap compressCss
```

## Rendering tags a little differently

The Hakyll website has really nice instructions on how to add tags to a Hakyll blog and how to generate pages that aggregate aritcles containing a tag. Those instructions were pretty straight forward and all I wanted was to style things a little differently. Rather than render the tags as a series of comma-separated links, I wanted to render them as coloured tokens indtead.

```haskell
-- | Custom tag rendering
tagsFld :: String -> Tags -> Context a
tagsFld = tagsFieldWith getTags tagRenderLink (mconcat . intersperse "")

-- | Render one tag link
tagRenderLink :: String -> (Maybe FilePath) -> Maybe H.Html
tagRenderLink _   Nothing         = Nothing
tagRenderLink tag (Just filePath) =
  Just $ H.a ! A.href (toValue $ toUrl filePath) ! A.id "tag" $ toHtml tag
```

## Bootstrapifying table, img & blockquote

One of the first things I realised was that I could enhance tables and blockquotes with a little help from Bootstrap.

Initially I thought I could post process the HTML produced by the `pandocCompiler` using RegExp.

```haskell
processTables :: String -> String
processTables i =
  replaceAll "\n<table(.|\n)+</table>\n" processTable i

processTable :: String -> String
processTable ts
  | [_, attr, body]:_ <- ts =~ ("\n<table(.*)>(.+)</table>\n" :: String) :: [[String]] =
    "\n<div class=\"table-responsive-md\">\n<table " ++ attr ++ " class=\"table table-striped table-dark\">" ++ body ++ "</table>\n</div>\n"
  | otherwise = ts
```

But, I pretty soon realised that this was going to be a pretty fruitless game when multiple tables were present. Being POSIX regexps--I realise I could switch to the PCRE Perl compatible RegExp engine--

In the end, I decided this was going to be messy.

Some intuition came from the `relativizeUrls` function, which use `tagsoup` to parse HTML and process each tag. Adding the `table table-striped table-dark` class attributes to each table was dead easy:

```haskell
withBootstrapTables :: String -> String
withBootstrapTables = withTags tag
    where
        tag (TS.TagOpen "table" attrs) = TS.TagOpen "table" (attrs ++ [("class","table table-striped table-dark")])
        tag x = x
```

Note: I should note that TS in the code block above and those below come from the import `import qualified Text.HTML.TagSoup as TS`.
This maps over each tag using `withTags :: (TS.Tag String -> TS.Tag String) -> String -> String`, matches the `TS.TagOpen` tags with a name "table and add the `table table-striped table-dark` class attribute.

Making tables responsive is a slightly more tricky problem because we can just add new tags around a table using the `withTags` function. Turns out Hakyll recently (as of [version 4.12.0.0](https://github.com/jaspervdj/hakyll/blob/v4.12.0.0/CHANGELOG.md#hakyll-41200)-- lucky me) added a related function `withTagList :: ([TS.Tag String] -> [TS.Tag String]) -> String -> String`. In this case, we need to provide a function that takes as input a list of all the Tags and returns a list of Tags. The nice thing about this is that we can fold over the list as opposed to map, which means we have an oppotunity to add extra elements if need be.

Tags can also be enhanced with Bootstrap and some custom CSS. You should be able to see a little preview of what they look like to the right.

> In the long history of humankind (and animal kind, too) those who learned to collaborate and improvise most effectively have prevailed.
> <footer class="blockquote-footer">Charles Darwin</footer>

Here we make use of the `withTags` function.

```haskell
withBootstrapQuotes :: String -> String
withBootstrapQuotes = withTags tag
    where
        tag (TS.TagOpen "blockquote" attrs) = TS.TagOpen "blockquote" (attrs ++ [("class","blockquote text-right")])
        tag x = x
```

We can also make images Bootstrap using the `.img-fluid` class. One wrinkle is that Pandoc's markdown supports adding attributes to `img` tags, which could be useful for adjusting `img` properties in special cases. The problem is that the `.img-fluid` class attribute can interfere with other custom attributes introduced via Pandoc. So in the case where other class attributes are already on the `img` tag, we'd like to avoid introducing the `.img-fluid` class attribute.

```haskell
withBootstrapImgs :: String -> String
withBootstrapImgs = withTags tag
    where
        tag (TS.TagOpen "img" attrs) =
            if elem "class" (fst $ unzip attrs)
            then TS.TagOpen "img" attrs
            else TS.TagOpen "img" (attrs ++ [("class", "img-fluid")])
        tag x = x
```